# 프로세스 스케줄링

> 주어진 프로세스가 여러 개인 경우, 프로세스 처리순서를 결정하는 것

## 스케줄링 단계

1. 상위단계 스케줄링
   - 시스템에 작업들이 들어오면 작업 큐에 들어가고 자원을 효율적으로 이용할 수 있도록 함 

2. 중간단계 스케줄링
   - 시스템에 대한 단기적인 부하를 조절

3. 하위단계 스케줄링
   - 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할을 수행
   - 수행 주체는 `디스패처(dispatcher)`

## 스케줄링의 목표

- 공정성
  - 모든 프로세스가 적정 수준에서 CPU를 사용할 수 있도록 함
- 균형
  - 시스템 자원이 충분히 활용될 수 있게 함

### 운영체제의 유형에 따른 스케줄링의 목표

- 일괄 처리 운영체제
  - 처리량의 극대화
  - 반환시간의 최소화
  - cpu 활용의 극대화

- 시분할 운영체제
  - 빠른 응답시간
  - 과다한 대기시간 방지

- 실시간 운영체제
  - 처리기한 맞춤

> 처리량 : 주어진 시간에 처리한 프로세스 수

> 반환시간 : 프로세스 생성 시점부터 종료까지의 소요시간

> 응답시간 : 요청한 시점부터 반응이 시작되는 시점까지의 소요시간

> 대기시간 : 프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합

## 스케줄링 정책

### 선점(preemptive) 스케줄링 정책

- 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식
- 우선순위가 높은 프로세스가 들어오면 우선순위가 낮은 프로세스를 중단시키고 CPU를 할당
  - 실시간 시스템, 시분할 시스템
- 컨텍스트 스위칭에 따른 오버헤드 (비용) 발생
  - 운영체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함

### 비선점(non-preemptive) 스케줄링 정책

- 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식
- CPU를 할당받아 실행이 시작된 프로세스는 대기상태나 종료상태로 전이될 때까지 계속 실행상태에 있게 됨
- 강제적인 문맥 교환이 없어 오버헤드 발생하지 않음
- 긴 프로세스가 실행중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생

> 컨텍스트(문맥) : CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태

> 컨텍스트 스위칭 : CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업

## 스케줄링의 평가 기준

### 평균대기시간

- 각 프로세스가 수행이 완료될 때까지 `준비 큐에서 기다리는 시간`의 합의 평균값

### 평균반환시간

- 각 프로세스가 생성된 시점부터 `완료된 시점까지의 시간`의 평균값

## 스케줄링 알고리즘

### FCFS(First-Come, First-Served)

- 준비 큐에 도착한 순서에 따라 디스패치 
- 비선점 방식

- 장점
  - 가장 간단하다
- 단점
  - 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음(시분할 / 실시간 운영체제에는 부적합)
  - 프로세스의 도착 순서에 따라 평균반환시간이 크게 변함

### SJF(Shortest-Job-First)

- 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치
- 비선점 방식

- 장점
  - 일괄처리 환경에서 구현하기 쉬움
- 단점
  - 실제로는 먼저 처리할 프로세스의 CPU 시간을 예상할 수 없음
  - 새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음 (비선점 방식이라 기존에 실행되고 있는 긴 프로세스를 종료 시킬 수 없으므로)

### SRTF(Shortest-Remaining-Time-First)

- 준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치
- SJF 알고리즘의 선점 방식

- 장점
  - SJF보다 평균대기시간이나 평균반환시간에서 효율적임
- 단점
  - 실제로는 프로세스의 CPU 시간을 예상할 수 없음
  - 각 프로세스의 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼

### RR(Round-Robin)

- 준비 큐에 도착한 순서대로 디스패치하지만 정해진 시간 할당량에 의해 시간 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비 큐의 맨 뒤로 이동
- 선점 방식

- 장점
  - CPU를 독점하지 않고 공평하게 이용 (시분할 운영체제에 적합)
- 단점
  - 시간 할당량이 너무 크면 FCFS 스케줄링과 동일
  - 시간 할당량이 너무 작으면 컨텍스트 스위칭 발생으로 오버헤드가 커짐

### HRN(Highest-Response-Ratio-Next)

- 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치
- SJF 방식에서는 실행시간이 짧다고 예상되는 것을 먼저 디스패치했다. 이에 더해서 대기 시간이 길어지는 프로세스에게 우선순위를 부여
- 비선점 방식

> 응답 비율 = (대기시간 + 실행시간) / 실행시간 = 대기시간 / 실행시간 + 1
> 예상 실행 시간이 짧을수록, 대기시간이 길수록 응답비율이 커짐

- 장점
  - 예상실행시간이 긴 프로세스도 오래 대기하면 응답비율이 커져 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능
- 단점
  - 실제로는 프로세스의 CPU 시간을 예상할 수 없음

### 다단계 피드백 큐(Multi-Level Feedback Queue)

- I/O 바운드 프로세스와 CPU 바운드 프로세스를 구분하여 서로 다른 시간 할당량 부여
- 단계 1부터 단계 n까지 하나씩의 준비 큐 존재
- 단계가 커질수록 시간 할당량도 커짐
- k 단계에서 완료되지 않은 프로세스는 k+1 단계(k단계보다 더 큰 시간할당량을 가진 큐)로 이동
- k 단계는 앞선 단계들의 프로세스가 다 처리된 후에 처리 가능
- 선점 방식
- 특징
  - I/O 바운드 프로세스는 높은 우선권 유지
    - I/O 바운드 프로세스는 어차피 CPU를 많이 사용하지 않기 때문에 높은 우선권을 부여하여 빠르게 처리
  - CPU 바운드 프로세스는 낮은 우선권이지만 긴 시간 할당량
    - CPU 바운드 프로세스는 CPU를 많이 사용하기 때문에 낮은 우선권을 부여하지만 시간 할당량을 늘려 처리

